"""
VELOCITY VERLET: velocity Verlet time integration of
a body moving in orbit

Produces plots of the position of the particle
and its energy, both as function of time. Also
saves both to file.

The potential is V(x) = a*x^4 - b*x^2, where
a and b are hard-coded in the main() method
and passed to the functions that
calculate force and potential energy.
"""

import sys
import math
import numpy as np
import matplotlib.pyplot as pyplot
from Particle3Dsos import Particle 




    #i think we need to incorporate leap_pos2nd in all pos
def get_separation(p_list):
    """
    Method that calculates all necessary separations to return as an array
    
    :param p_list : list
    :return: N x N array
    """
    N= len(p_list)
    #Opens [N,N] array to hold pair separation values in scalar
    mod_array = np.zeros([N,N])
    #Opens [N,N,3] array to hold pair separation as vector (x,y,z)
    separations = np.zeros([N,N,3])
    for i in range(N):
        for j in range(N):
            separations[i,j] = p_list[i].pos - p_list[j].pos
            mod_array[i,j] = np.linalg.norm(separations[i,j])
            
    return mod_array
    


# Begin main code
def main():
    # Read name of output file from command line
    if len(sys.argv)!=2:
        print("Wrong number of arguments.")
        print("Usage: " + sys.argv[0] + " <output file>")
        sys.exit()
    else:
        outfile_name = sys.argv[1]

    # Open output file
    outfile = open(outfile_name, "w")
    #Opens o2_vibration in symplectic and verlet
    
    #Reads in simulation parameters 
    with open("sim_parameter.txt","r") as my_input:
        #Reads first line only
        solar_data = my_input.readline().split(" ")
        G = float(solar_data[0])
        dt = float(solar_data[1])
        numstep = int(solar_data[2])
        
    #Set up celestial bodies from input file
    f = open("p_setup.txt")
    p_list = []
    
   #Calculates length of file 
    count = sum(1 for line in open('p_setup.txt'))
    for i in range(count):
        val = f.readline()
        part = Particle.new_particle(val)
        p_list.append(part)      
   
    f.close()
    
    def get_force(p_list):
        #returns an array of 1XN float of every bodies' force
        #you would want to sum up force[i] with combinations of sep[i,j]
        N = len(p_list)
        sys_force = []
        sep = get_separation(p_list)
        force = np.zeros([N,N])
        #Forms (N,N) array of bodies
        for i in range(N):
            for j in range(N):
                #Gets the force numerator
                if i!=j:
                    force[i,j] = G*p_list[i].mass*p_list[j].mass/(sep[i,j])**2
                else:
                    continue
        sys_force = force.sum(axis=1)
                
        return sys_force 

    def update_vel(p_list, dt):
    
        N = len(p_list)
        sys_velocity = np.zeros([3,N])
        force = get_force(p_list)
        for i in range(N):
            f = force[i]
            sys_velocity[i] = p_list[i].leap_vel(dt, f)
        
        return sys_velocity    
        
    def update_pos(p_list, dt):
        N = len(p_list)
        sys_position = np.zeros([3, N])
        #Opens [N,N] array to hold pair separation values in scalar
        force = get_force(p_list)
        for i in range(N):
            f = force[i]
            term_1 = p_list[i].leap_pos2nd(dt,f)
            term_2 = dt*(update_vel(p_list,dt)[i])
            term_3 = (dt**2)*f/p_list[i].mass
            sys_position[i] += term_1 + term_2 + term_3
    
        return sys_position
    
    def sys_pot_energy(p_list, G, dt):
        """
        Returns potential energy of system in an array {scalar}
        Sum of potential from every interaction between bodies
        """
        N = len(p_list)
        potential = np.zeros([N,N])
        force = get_force(p_list)
        for i in range(N):
            for j in range(N):
                if i!=j:
                    r_vec = p_list[i].leap_pos2nd(dt, force[i]) - p_list[j].leap_pos2nd(dt, force[j])
                    r_mag = np.linalg.norm(r_vec)
                    potential = -G*p_list[i].mass*p_list[j].mass/(r_mag)
                else:
                    continue
            
        sys_potential= potential.sum(axis=0)
        return sys_potential
            
    
    print("poo")
    print(get_separation(p_list))
    print("force", get_force(p_list))
         
          
    print("vel", update_vel(p_list,dt))
    print("pos", update_pos(p_list,dt))
    print("KE",Particle.sys_kinetic(p_list))
    print("PE",sys_pot_energy(p_list, G, dt))
    
  
    # Write out initial conditions
    energy = sys_pot_energy(p_list, G, dt) + Particle.sys_kinetic(p_list)
    outfile.write("{0:f} {1:f} {2:12.8f}\n".format(time,update_pos,energy))
                                                                                              
    # Get initial force
    force = get_force(p_list)

    # Initialise data lists for plotting later
    #t = np.arange(numstep)*dt
    time_list = np.arange(numstep)*dt
    pos_list = [update_pos(p_list, dt)]
    energy_list = [energy]

    # Start the time integration loop
    
    for i in range(numstep):
        # Update particle position
        update_pos(p_list,dt)
        
        # Update force
        force_new = get_force(p_list)
        # Update particle velocity by averaging
        # current and new forces
        update_vel(p_list, dt)
        #p1.leap_vel(dt, 0.5*(force+force_new))
        
        # Re-define force value
        force = force_new

        # Increase time
        time += dt
        
        # Output particle information
        energy = sys_pot_energy(p_list, G, dt) + Particle.sys_kinetic(p_list)
        outfile.write("{0:f} {1:f} {2:12.8f}\n".format(time,update_pos(p_list,dt),energy))

        # Append information to data lists
        time_list.append(time)
        pos_list.append(update_pos(p_list))
        energy_list.append(energy)
    

    # Post-simulation:
    # Close output file
    outfile.close()
    
    # Plot particle trajectory to screen
    pyplot.title('Velocity Verlet: position vs time')
    pyplot.xlabel('Time')
    pyplot.ylabel('Position')
    pyplot.plot(time_list, pos_list)
    pyplot.show()

    # Plot particle energy to screen
    pyplot.title('Velocity Verlet: total energy vs time')
    pyplot.xlabel('Time')
    pyplot.ylabel('Energy')
    pyplot.plot(time_list, energy_list)
    pyplot.show()


# Execute main method, but only when directly invoked
if __name__ == "__main__":
    main()

